# -*- coding: utf-8 -*-
"""Assignment-1: Linear Data Structures

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BLajUabbSnYP4J-mRWC1uwnntHDtYLbX
"""

#1)Delete the elements in an linked list whose sum is equal to zero
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def deleteZeroSumSublists(head):
    dummy = ListNode(0)
    dummy.next = head
    curr = dummy
    prefixSum = 0
    sumMap = {}

    while curr:
        prefixSum += curr.val
        if prefixSum in sumMap:
            # remove all nodes between the previous node with the same sum
            # and the current node
            prev = sumMap[prefixSum]
            node = prev.next
            while node != curr:
                prefixSum += node.val
                del sumMap[prefixSum]
                node = node.next
            prev.next = curr.next
        else:
            sumMap[prefixSum] = curr
        curr = curr.next

    return dummy.next
# Create a linked list
node1 = ListNode(1)
node2 = ListNode(2)
node3 = ListNode(-3)
node4 = ListNode(3)
node5 = ListNode(1)
node1.next = node2
node2.next = node3
node3.next = node4
node4.next = node5

# Call the function
head = deleteZeroSumSublists(node1)

# Print the modified linked list
while head:
    print(head.val, end=" ")
    head = head.next

#2)Reverse a linked list in groups of given size

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverseKGroup(head, k):
    dummy = ListNode(0)
    dummy.next = head
    prev, curr = dummy, head

    while True:
        count = k
        groupTail = curr
        while count and groupTail:
            groupTail = groupTail.next
            count -= 1
        if count:
            break
        prevTail, currTail = prev, curr
        while curr != groupTail:
            nextNode = curr.next
            curr.next = prevTail
            prevTail, curr = curr, nextNode
        currTail.next = groupTail
        prev.next, prev = prevTail, currTail

    return dummy.next
# Create a linked list: 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> None
head = ListNode(1)
head.next = ListNode(2)
head.next.next = ListNode(3)
head.next.next.next = ListNode(4)
head.next.next.next.next = ListNode(5)
head.next.next.next.next.next = ListNode(6)

# Reverse the linked list in groups of size 2
new_head = reverseKGroup(head, 2)

# Print the reversed list: 2 -> 1 -> 4 -> 3 -> 6 -> 5 -> None
while new_head:
    print(new_head.val, end=" -> ")
    new_head = new_head.next
print("None")

#3)Merge a linked list into another linked list at alternate positions.

def merge_alternate(head1, head2):
    if not head1:
        return head2
    if not head2:
        return head1
    cur1 = head1
    cur2 = head2
    while cur1 and cur2:
        next1 = cur1.next
        next2 = cur2.next
        cur1.next = cur2
        cur2.next = next1
        cur1, cur2 = next1, next2
    if cur2:
        cur1.next = cur2
    return head1

#4)In an array, Count Pairs with given sum

def count_pairs(arr,k):
  freq = {}
  count = 0
  for num in arr:
    if num in freq:
      freq[num]+=1
    else:
      freq[num] = 1
  for num in arr:
    if k - num in freq:
      count += freq[k - num]
      if k - num == num:
        count -= 1
  return count // 2
arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
k = 10
count = count_pairs(arr, k)
print("Number of pairs that sum up to {}: {}".format(k, count))

#5) Find duplicates in an array 
def find_duplicates(arr):
    freq = {}
    duplicates = []
    for num in arr:
        if num in freq:
            duplicates.append(num)
        freq[num] = freq.get(num, 0) + 1
    if duplicates:
        print("Duplicates:", duplicates)
    else:
        print("No duplicates found.")
arr = [1, 2, 3, 4, 2, 5, 4, 6]
find_duplicates(arr)

#6)Find the Kth largest and Kth smallest number in an array
import heapq

def kth_smallest(arr, k):
    heap = arr[:k]
    heapq.heapify(heap)
    for i in range(k, len(arr)):
        if arr[i] < heap[0]:
            heapq.heappop(heap)
            heapq.heappush(heap, arr[i])
    return heap[0]

def kth_largest(arr, k):
    heap = [-x for x in arr[:k]]
    heapq.heapify(heap)
    for i in range(k, len(arr)):
        if arr[i] > -heap[0]:
            heapq.heappop(heap)
            heapq.heappush(heap, -arr[i])
    return -heap[0]
arr = [1, 4, 2, 7, 5, 9]
k = 3

kth_smallest_number = kth_smallest(arr, k)
kth_largest_number = kth_largest(arr, k)

print(f"The {k}th smallest number in the array is: {kth_smallest_number}")  
print(f"The {k}th largest number in the array is: {kth_largest_number}")

#7)Move all the negative elements to one side of the array

def move_negatives(arr):
    left = 0
    right = len(arr) - 1
    
    while left <= right:
        if arr[left] < 0 and arr[right] < 0:
            # both elements are negative, move the left pointer to the right
            left += 1
        elif arr[left] >= 0 and arr[right] < 0:
            # left element is positive and right element is negative, swap them
            arr[left], arr[right] = arr[right], arr[left]
            left += 1
            right -= 1
        elif arr[left] >= 0 and arr[right] >= 0:
            # both elements are positive, move the right pointer to the left
            right -= 1
        else:
            # left element is negative and right element is positive, swap them
            left += 1
            right -= 1
    
    return arr
arr = [-1, 2, -3, 4, 5, 6, -7, 8, -9]
move_negatives(arr)

#8)Reverse a string using a stack data structure
def reverse_string_using_stack(string):
    stack = []
    for char in string:
        stack.append(char)
    
    reversed_string = ""
    while len(stack) > 0:
        reversed_string += stack.pop()
    
    return reversed_string
string = "Hello, World!"
reverse_string_using_stack(string)

#9)Evaluate a postfix expression using stack
def evaluate_postfix(expression):
    stack = []
    for token in expression:
        if token.isdigit():
            stack.append(int(token))
        else:
            operand2 = stack.pop()
            operand1 = stack.pop()
            result = None
            if token == "+":
                result = operand1 + operand2
            elif token == "-":
                result = operand1 - operand2
            elif token == "*":
                result = operand1 * operand2
            elif token == "/":
                result = operand1 / operand2
            stack.append(result)
    return stack.pop()
expression = "34+5*"
result = evaluate_postfix(expression)
print(result)

#10)Implement a queue using the stack data structure
class Queue:
    def __init__(self):
        self.stack_in = []
        self.stack_out = []

    def enqueue(self, value):
        self.stack_in.append(value)

    def dequeue(self):
        if not self.stack_out:
            while self.stack_in:
                self.stack_out.append(self.stack_in.pop())
        if not self.stack_out:
            raise Exception("Queue is empty")
        return self.stack_out.pop()
q = Queue()
q.enqueue(1)
q.enqueue(2)
q.enqueue(3)
print(q.dequeue())  
print(q.dequeue())  
q.enqueue(4)
print(q.dequeue()) 
print(q.dequeue())







